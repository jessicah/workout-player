@page "/novid/{content?}"
@using Blazor.Bluetooth
@using BluetoothLE.Components.Views
@using BluetoothLE.Models.ContentLibrary
@using Microsoft.AspNetCore.Html
@using Dynastream.Fit;
@using Microsoft.EntityFrameworkCore
@using Microsoft.Extensions.Caching.Memory
@using MongoDB.Driver
@inject IJSRuntime jsRuntime
@inject IConfiguration Configuration
@inject IDbContextFactory<Models.AthleteContext> DbFactory
@inject IHttpClientFactory HttpClientFactory
@inject ILogger<NoVidPlayer> Logger
@inject Utilities.StravaOAuth OAuth
@inject Utilities.BluetoothHandler BluetoothHandler
@inject BluetoothLE.Services.SufferService Suffer
@implements IAsyncDisposable
@rendermode @(new InteractiveServerRenderMode(prerender: false))

<PageTitle>BLE</PageTitle>

@if (_timer is null || _timer.Period == Timeout.InfiniteTimeSpan)
{
    <button style="left: 4px; top: 4px;" onclick="@BluetoothHandler.ConnectAsync">Connect to BLE</button>

    if (IsAuthenticated)
    {
        <button id="strava-upload" onclick="@UploadAsync" style="right: 4px; left: unset; background-color: rgb(215 70 0); color: white; padding-left: 8px; padding-right: 8px; top: 4px"><i class="fa-brands fa-strava"></i></button>
    }
}

<div @onclick="@(async e => await TogglePlaybackAsync())">

    <style type="text/css">
        .indicator {
        stroke: yellow;
        stroke-width: 1px;
        z-index: 100;
        }
    </style>

    <article>
        @if (videoHandler is not null && videoHandler.Story(currentPosition) is StorylineParameters parameters)
        {
            <StoryLine Parameters="parameters" />
        }
    </article>

    @if (whip is StorylineParameters whipObject)
    {
        <div id="whip"><div>@whipObject.Text.En</div></div>
    }

    @if (currentTargets is WorkoutParameters targets)
    {
        var currentPower = FromParameters(targets).Value;
        var currentCadence = targets.Rpm?.Value ?? 0;

        <div id="workout-display">
            <div id="heart-rate" class="target-grid">
                <div class="current-value">@FromInt(actualHeartRate)</div>
                <div class="current-icon"><i class="fa-light fa-heart icon"></i></div>
                <div class="target-value"></div>
                <div class="upcoming-value"></div>
            </div>
            <div id="power" class="target-grid">
                <div class="target-value">@currentPower</div>
                <UpcomingValue CurrentTarget="currentPower" CurrentPosition="currentPosition"
                Parameters="effortChangeObject" UpcomingParameters="upcomingTargets"
                GetUpcoming="(parameters) => FromParameters(parameters).Value"></UpcomingValue>
                <div class="current-value" style="background-color: @ColorDiff(currentPower, actualPower ?? 0, 10)">@FromInt(actualPower)</div>
                <div class="current-icon"><i class="fa-light fa-bolt icon"></i></div>
            </div>
            <div id="cadence" class="target-grid">
                <div class="target-value">@currentCadence</div>
                <UpcomingValue CurrentTarget="currentCadence" CurrentPosition="currentPosition"
                Parameters="effortChangeObject" UpcomingParameters="upcomingTargets"
                GetUpcoming="(parameters => parameters.Rpm?.Value ?? 0)"></UpcomingValue>
                <div class="current-value" style="background-color: @ColorDiff(currentCadence, actualCadence ?? 0, 5)">@FromInt(actualCadence)</div>
                <div class="current-icon"><i class="fa-light fa-sync icon"></i></div>
            </div>
            <div id="graph-container">
                <div id="graph">
                    @if (workoutBuilder is not null)
                    {
                        <svg width="@workoutBuilder.Width" height="@workoutBuilder.Height" viewBox="0 0 @workoutBuilder.Width @workoutBuilder.Height">
                            <rect width="@workoutBuilder.Width" height="@workoutBuilder.Height" x="0" y="0" fill="none"/>
                            <g>
                                @foreach (var item in workoutBuilder.Paths())
                                {
                                    <path d="@item.Fill" fill="@item.Colour" fill-opacity="1" stroke="none" class="@item.Class"></path>
                                }
                            </g>
                        </svg>
                    }
                </div>

                <div id="hr-graph">

                    @if (heartRateBuilder is not null)
                    {
                        <svg width="@heartRateBuilder.Width" height="@heartRateBuilder.Height" viewBox="0 0 @heartRateBuilder.Width @heartRateBuilder.Height">
                            <rect width="@heartRateBuilder.Width" height="@heartRateBuilder.Height" x="0" y="0" fill="none" />
                            <g>
                                @foreach (var item in heartRateBuilder.Paths())
                                {
                                    <path d="@item.Stroke" fill="none" stroke="@item.Colour" class="@item.Class"></path>
                                }
                            </g>
                        </svg>
                    }
                </div>
                <div id="power-graph">

                    @if (powerBuilder is not null)
                    {
                        <svg width="@powerBuilder.Width" height="@powerBuilder.Height" viewBox="0 0 @powerBuilder.Width @powerBuilder.Height">
                            <rect width="@powerBuilder.Width" height="@powerBuilder.Height" x="0" y="0" fill="none" />
                            <g>
                                @foreach (var item in powerBuilder.Paths())
                                {
                                    <path d="@item.Stroke" fill="none" stroke="@item.Colour" class="@item.Class"></path>
                                }
                            </g>
                        </svg>
                    }
                </div>
                <div id="elapsed-time">@FormatTimeSpan(elapsedTime)</div>
                <div id="track-remaining-time"><div>@FormatTimeSpan(trackRemainingTime)</div></div>
                <div id="total-remaining-time">@FormatTimeSpan(workoutRemainingTime)</div>
            </div>
        </div>
    }

</div>

<audio id="effort_increase" src="sounds/effort_increase.mp3"></audio>
<audio id="effort_decrease" src="sounds/effort_decrease.mp3"></audio>
<audio id="effort_change_coming" src="sounds/effort_change_coming.mp3"></audio>
<audio id="attack" src="sounds/attack.mp3"></audio>
<audio id="slide_in" src="sounds/slide_in.mp3"></audio>
<audio id="slide_out" src="sounds/slide_out.mp3"></audio>
<audio id="stand" src="sounds/stand.mp3"></audio>
<audio id="surge" src="sounds/surge.mp3"></audio>

<script type="text/javascript">
    console.log("setting up sound effect init function...");
    window.audioTracks = {};
    window.setupSoundEffects = () => {
    document.querySelectorAll('audio').forEach((audioElement) => {
    console.log("initializing sound effects");

    const id = audioElement.id;

    let context = new AudioContext();
    let track = context.createMediaElementSource(audioElement);

    track.connect(context.destination);

    window.audioTracks[id] = { element: audioElement, context, track };
    });

    window.playSoundEffect = (id) => window.audioTracks[id].element.play();
    }

    console.log("trying to enter fullscreen...");
    document.documentElement.requestFullscreen({ navigationUI: "hide" })
    .then(() => { console.log("entered fullscreen") })
    .catch((err) => { console.log(`failed to enter fullscreen: ${err.message}`) });
</script>

@code {
    [Parameter]
    public string Content { get; set; } = "Indoor Cycling";

    private string ColorDiff(int currentTarget, int actualValue, int safeValue)
    {
        int diff = currentTarget - actualValue;

        //Console.WriteLine($"ColorDiff: {currentTarget} - {actualValue} = {diff}");

        if (Math.Abs(diff) <= safeValue) {
            //Console.WriteLine($"    Within margin of '{safeValue}'");
            return "none";
        }

        if (diff > (safeValue * 10)) diff = safeValue * 10;
        if (diff < (safeValue * -10)) diff = safeValue * -10;

        double percentage = Math.Abs((double)diff) / (double)(safeValue * 10);

        if (diff > 0) {
            //Console.WriteLine($"    Below target: {percentage}%");
            int red = (int)(255 * percentage);
            return $"rgb({red} 0 0 / 50%)";
        }
        else {
            //Console.WriteLine($"   Above target: {percentage}");
            int blue = (int)(255 * percentage);
            int green = (int)(127 * percentage);
            return $"rgb(0 {green} {blue} / 50%)";
        }
    }

    int currentPosition = 0;

    WorkoutParameters? currentTargets = null;
    WorkoutParameters? upcomingTargets = null;
    StorylineParameters? whip = null;
    Object<WorkoutParameters>? effortChangeObject = null;

    MarkupString FromInt(int? value) => value is null ? new MarkupString("&mdash;") : new MarkupString($"{value.Value}");

    TimeSpan elapsedTime = TimeSpan.Zero;
    TimeSpan trackRemainingTime = TimeSpan.Zero;
    TimeSpan workoutRemainingTime = TimeSpan.Zero;

    PeriodicTimer? _timer;
    Task? _timerTask;
    bool _disposed = false;

    string Story = string.Empty;

    bool initSoundEffects = false;

    record struct SoundEffect(int StartTime, int Duration, string EffectName, bool Started);
    record struct Target(int StartTime, int Duration, int Power, bool Increase);

    Queue<SoundEffect> soundEffects = [];
    Queue<Target> targetChanges = [];

    Utilities.FitFileHandler? _fitFileHandler;

    async Task TogglePlaybackAsync()
    {
        try
        {
            if (initSoundEffects is false)
            {
                initSoundEffects = true;

                await jsRuntime.InvokeVoidAsync("setupSoundEffects");
            }

            Console.WriteLine("Toggling workout...");

            if (_timer is null)
            {
                Logger.LogError("Unable to toggle playback state, have no timer!");

                return;
            }

            if (_timerTask is null)
            {
                _timerTask = UpdateState();
            }

            if (_timer.Period == Timeout.InfiniteTimeSpan)
            {
                startTime = System.DateTime.UtcNow;

                _timer.Period = TimeSpan.FromMilliseconds(100);

                if (_fitFileHandler is null)
                {
                    _fitFileHandler = new(Content);
                }
            }
            else
            {
                _timer.Period = Timeout.InfiniteTimeSpan;
            }
        } catch (Exception exn)
        {
            Logger.LogError($"Unable to toggle playback: {exn.Message}");
            Logger.LogError($"Stack Trace: {exn.StackTrace}");
        }
    }

    private async Task PlaybackEndedAsync(Blazored.Video.Support.VideoState state)
    {
        Logger.LogInformation("Playback has ended, closing fit file");

        if (_timer is not null)
        {
            _timer.Period = Timeout.InfiniteTimeSpan;
        }

        CloseFitFile();

        await InvokeAsync(StateHasChanged);
    }

    private void CloseFitFile()
    {
        if (_fitFileHandler is null)
        {
            Logger.LogInformation("Have already closed the fit file, aborting");

            return;
        }

        if (startTime is null) startTime = System.DateTime.UtcNow;
        if (endTime is null) endTime = System.DateTime.UtcNow;

        var elapsed = (float)(endTime.Value - startTime.Value).TotalSeconds;

        throw new Exception("Upgrade NoVidPlayer...");
        //_memoryStream = _fitFileHandler?.Close(startTime.Value, endTime.Value, 0, Models.Lap.TotalSummary(_laps));

        startTime = null;
        endTime = null;

        _fitFileHandler?.Dispose();
        _fitFileHandler = null;
    }

    private MemoryStream? _memoryStream;

    private System.DateTime? startTime = null;
    private System.DateTime? endTime = null;

    private IReadOnlyList<WorkoutTrigger> workoutJson = [];

    private bool IsAuthenticated { get; set; } = false;

    protected override async Task OnInitializedAsync()
    {
        // TODO: support multiple users, for now, just hard-coding `1`.
        try
        {
            //IsAuthenticated = await OAuth.HasAccessToken(1);
        }
        catch { }

        var contentItem = await Suffer.ContentCollection.Find(item => item.Id == Content).SingleAsync();

        var workoutTriggers = contentItem.Workout;

        var videoTriggers = contentItem.Storylines;

        if (videoTriggers is not null && videoTriggers.Count == 1)
        {
            videoHandler = new(videoTriggers[0]);

            Logger.LogInformation("Started storyline");
        }

        _timer = new(Timeout.InfiniteTimeSpan);

        if (workoutTriggers is not null && workoutTriggers.Count > 0)
        {
            workoutJson = workoutTriggers;

            BuildWorkoutGraph(workoutJson);

            workoutHandler = new(workoutJson);

            currentTargets = workoutHandler.Targets(0);
        }

        // Just testing this out, want to do a few other tests with BLE and various pairing states
        //await BluetoothHandler.ForgetAsync();

        BluetoothHandler.OnChange += async (Utilities.BluetoothHandler.BluetoothData data) =>
        {
            if (data.HeartRate is int hr) actualHeartRate = (byte)hr;
            if (data.Cadence is int cadence) actualCadence = (byte)cadence;
            if (data.Power is int power) actualPower = (ushort)power;

            await InvokeAsync(StateHasChanged);
        };

        await InvokeAsync(StateHasChanged);
    }

    string FormatColour(IReadOnlyList<double> components)
    {
        int Rgb(double percentage) => (int)(255.0 * percentage);

        if (components.Count == 4)
        {
            return $"rgb({Rgb(components[0])} {Rgb(components[1])} {Rgb(components[2])} / {(int)(components[3] * 100)}%)";
        }
        else
        {
            return $"rgb({Rgb(components[0])} {Rgb(components[1])} {Rgb(components[2])})";
        }
    }

    ContentHandler.VideoHandler? videoHandler = null;
    ContentHandler.WorkoutHandler? workoutHandler = null;

    private System.DateTime last = System.DateTime.Now;

    private Track? _lastTrack = null;

    private (int Offset, Track Track)? GetCurrentTrack(int offset)
    {
        int currentOffset = 0;

        foreach (var root in workoutJson)
        {
            foreach (var track in root.Tracks)
            {
                if (offset >= currentOffset && offset <= currentOffset + track.Size)
                {
                    return (currentOffset, track);
                }

                currentOffset += track.Size;
            }
        }

        return null;
    }

    private long lastTick = System.DateTime.UtcNow.Ticks;

    private System.TimeOnly lastUpdate = TimeOnly.FromDateTime(System.DateTime.UtcNow);

    private int lastLength = 0;

    private bool writtenStartEvent = false;

    private async Task UpdateState()
    {
        try
        {
            while (await _timer!.WaitForNextTickAsync())
            {
                if (_disposed)
                    return;

                try
                {
                    var videoTime = (System.DateTime.UtcNow - startTime.Value).TotalSeconds;

                    currentPosition = (int)(videoTime * 1000);

                    if (workoutBuilder is not null)
                    {
                        workoutBuilder.IndicatorPosition = currentPosition;
                    }

                    currentTargets = workoutHandler?.Targets(currentPosition);
                    upcomingTargets = workoutHandler?.NextTargets(currentPosition);
                    effortChangeObject = workoutHandler?.EffortChangeObject(currentPosition);
                    whip = videoHandler?.Whip(currentPosition);

                    if (workoutHandler?.SoundEffect(currentPosition) is WorkoutParameters workoutSoundEffect)
                    {
                        Logger.LogInformation($"Playing sound effect: {workoutSoundEffect.Key}");

                        await jsRuntime.InvokeVoidAsync("playSoundEffect", workoutSoundEffect.Key);
                    }

                    if (videoHandler?.SoundEffect(currentPosition) is StorylineParameters videoSoundEffect)
                    {
                        await jsRuntime.InvokeVoidAsync("playSoundEffect", videoSoundEffect.Key);
                    }

                    var currentTrack = GetCurrentTrack(currentPosition);

                    try
                    {
                        if (currentTrack is not null)
                        {
                            var elapsed = currentPosition - currentTrack.Value.Offset;
                            trackRemainingTime = TimeSpan.FromMilliseconds(currentTrack.Value.Track.Size - elapsed).Add(TimeSpan.FromSeconds(1));
                        }

                        // GetDurationAsync() returns a non-integer value, throws exception
                        //workoutRemainingTime = TimeSpan.FromSeconds(await video.GetDurationAsync() - (int)videoTime);
                        int workoutTime = workoutJson.SelectMany(root => root.Tracks.Select(track => track.Size)).Sum();

                        if (workoutTime > currentPosition)
                        {
                            workoutRemainingTime = TimeSpan.FromMilliseconds(workoutTime - currentPosition);
                        }
                        else
                        {
                            workoutRemainingTime = TimeSpan.Zero;
                        }

                        elapsedTime = TimeSpan.FromMilliseconds(currentPosition);
                    } catch (Exception exn)
                    {
                        Logger.LogError($"Error trying to update timers: {exn.Message}");
                        Logger.LogError($"Stack trace: {exn.StackTrace}");
                    }

                    var currentUpdate = TimeOnly.FromDateTime(System.DateTime.UtcNow);

                    int index = (int)Math.Floor(videoTime);

                    if (heartRateBuilder is not null)
                    {
                        heartRateBuilder.Data[index] = actualHeartRate ?? 0;
                        heartRateBuilder.Length = index + 1;
                    }

                    if (powerBuilder is not null)
                    {
                        powerBuilder.Data[index] = actualPower ?? 0;
                        powerBuilder.Length = index + 1;
                    }

                    if (cadenceBuilder is not null)
                    {
                        cadenceBuilder.Data[index] = actualCadence ?? 0;
                        cadenceBuilder.Length = index + 1;
                    }

                    //if (Math.Floor((currentUpdate - lastUpdate).TotalSeconds) > 0)
                    if (index == 0 && !writtenStartEvent)
                    {
                        writtenStartEvent = true;
                        startTime = System.DateTime.UtcNow;

                        _fitFileHandler?.AddStart(startTime.Value);
                        _fitFileHandler?.AddRecord(startTime.Value, actualHeartRate ?? 0, actualCadence ?? 0, actualPower ?? 0);

                    }
                    if (index > lastLength)
                    {
                        lastLength = index;
                        lastUpdate = currentUpdate.Add(TimeSpan.FromMilliseconds(-100));
                        lastTick = System.DateTime.UtcNow.Ticks;

                        _fitFileHandler?.AddRecord(System.DateTime.UtcNow, actualHeartRate ?? 0, actualCadence ?? 0, actualPower ?? 0);
                    }

                    await InvokeAsync(StateHasChanged);
                } catch (Exception innerExn)
                {
                    Logger.LogError($"Derp: {innerExn.Message}");
                }
            }
        }
        catch (OperationCanceledException exn)
        {
            // can we dispose of the timer here?
            Console.WriteLine($"update state has failed: {exn.Message}");
        }
    }

    string FormatTimeSpan(TimeSpan timeSpan)
    {
        if (timeSpan.Hours > 0)
        {
            return timeSpan.ToString(@"h':'mm':'ss");
        }
        else
        {
            return timeSpan.ToString(@"m':'ss");
        }
    }

    private Models.Stats? AthleteStats { get; set; }

    private WorkoutItem FromParameters(WorkoutParameters parameters)
    {
        if (AthleteStats is null)
        {
            using var context = DbFactory.CreateDbContext();

            try
            {
                AthleteStats = context.Stats.Where(item => item.Id == 1).SingleOrDefault();
            }
            catch (Exception exn)
            {
                Logger.LogError($"Unable to load athlete stats: {exn.Message}");

                return new(BluetoothLE.Target.FTP, 0);
            }
        }

        if (AthleteStats is null || parameters is null)
            return new(BluetoothLE.Target.FTP, 0);

        if (parameters.Nm is TypedValue<double> nm)
        {
            return new(BluetoothLE.Target.NM, (ushort)(AthleteStats.Nm * nm.Value));
        }
        else if (parameters.Ac is TypedValue<double> ac)
        {
            return new(BluetoothLE.Target.AC, (ushort)(AthleteStats.Ac * ac.Value));
        }
        else if (parameters.Map is TypedValue<double> map)
        {
            return new(BluetoothLE.Target.MAP, (ushort)(AthleteStats.Map * map.Value));
        }
        else if (parameters.Ftp is TypedValue<double> ftp)
        {
            return new(BluetoothLE.Target.FTP, (ushort)(AthleteStats.Ftp * ftp.Value));
        }
        else throw new ArgumentException("Don't have a power target to show");
    }

    private void BuildWorkoutGraph(IReadOnlyList<WorkoutTrigger> workout)
    {
        List<WorkoutItem> workoutValues = [];

        int trackOffset = 0;

        foreach (var section in workout)
        {
            //Console.WriteLine($"Processing section {section.Name}");

            foreach (var track in section.Tracks)
            {
                //Console.WriteLine($"  Processing track of type {track.Type}");

                int size = track.Size;

                if (track.SizeType != "time")
                {
                    //Console.WriteLine($"    Track doesn't have a duration; size type is {track.SizeType}");

                    continue;
                }

                for (int ix = 0; ix < track.Objects.Count; ++ix)
                {
                    var obj = track.Objects[ix];

                    if (obj.Type == StringKeys.Targets)
                    {
                        for (int iy = 0; iy < (obj.Size / 1000); ++iy)
                        {
                            workoutValues.Add(FromParameters(obj.Parameters));
                        }
                    }
                }

                trackOffset += track.Size;
            }
        }

        var maxPower = (int)Math.Ceiling((double)workoutValues.MaxBy(value => value.Value).Value / 10) * 10 + 50;

        //Console.WriteLine($"Max Power Value: {maxPower}W");

        // The new graph handling
        workoutBuilder = new GraphBuilder<WorkoutItem>(new WorkoutItemTransformer(), workoutValues.Count, 100, maxPower)
            {
                CreateStroke = false,
                JoinBlocks = false,
                Length = workoutValues.Count
            };
        heartRateBuilder = new GraphBuilder<int>(new ValueTransformer("rgb(255 0 0)"), workoutValues.Count, 100, 200)
            {
                CreateFill = false,
                JoinBlocks = false
            };
        cadenceBuilder = new GraphBuilder<int>(new ValueTransformer("rgb(0 0 255)"), workoutValues.Count, 100, 200)
            {
                CreateFill = false,
                JoinBlocks = false
            };
        powerBuilder = new GraphBuilder<int>(new ValueTransformer("rgb(255 255 255)"), workoutValues.Count, 100, maxPower)
            {
                CreateFill = false,
                JoinBlocks = false
            };

        workoutBuilder.Data = workoutValues.ToArray();
    }

    public async ValueTask DisposeAsync()
    {
        if (_disposed)
            return;

        _disposed = true;

        CloseFitFile();

        await BluetoothHandler.ForgetAsync();

        if (_timerTask is not null)
        {
            await _timerTask;
            _timerTask = null;
        }

        _timer?.Dispose();
        _timer = null;
    }

    public async Task UploadAsync()
    {
        string? accessToken = await OAuth.GetAccessToken(1);

        if (string.IsNullOrEmpty(accessToken))
        {
            Logger.LogInformation("Unable to acquire an access token for Strava, activity NOT saved!");

            return;
        }

        CloseFitFile();

        if (_memoryStream is null || _memoryStream.Length == 0)
        {
            Logger.LogError("Nothing to upload");

            return;
        }

        _memoryStream.Seek(0, SeekOrigin.Begin);

        using var httpClient = HttpClientFactory.CreateClient();

        httpClient.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", accessToken);

        var content = new MultipartFormDataContent();

        content.Add(new System.Net.Http.StreamContent(_memoryStream), "file", "workout.fit");
        content.Add(new StringContent("fit"), "data_type");
        content.Add(new StringContent("Ride"), "sport_type");
        content.Add(new StringContent("1"), "trainer");
        content.Add(new StringContent(string.IsNullOrEmpty(Content) ? "Indoor Workout" : $"The Sufferfest: {Content}"), "name");

        using var response = await httpClient.PostAsync("https://www.strava.com/api/v3/uploads", content);

        var body = await response.Content.ReadAsStringAsync();

        if (response.IsSuccessStatusCode == false)
        {
            Logger.LogError($"Failed to submit activity: {response.StatusCode}");
            Logger.LogError($"{body}");
        }
        else
        {
            Logger.LogInformation($"Successfully submitted activity!");
            Logger.LogInformation($"{body}");
        }
    }

    private GraphBuilder<WorkoutItem>? workoutBuilder = null;
    private GraphBuilder<int>? heartRateBuilder = null;
    private GraphBuilder<int>? powerBuilder = null;
    private GraphBuilder<int>? cadenceBuilder = null;

    int? actualHeartRate = null;
    int? actualCadence = null;
    int? actualPower = null;
}
