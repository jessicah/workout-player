@page "/content-player/{content?}"
@using Blazor.Bluetooth
@using BluetoothLE.Components.Views
@using BluetoothLE.Models.ContentLibrary
@using BluetoothLE.Utilities
@using Microsoft.AspNetCore.Html
@using Dynastream.Fit;
@using Microsoft.EntityFrameworkCore
@using Microsoft.Extensions.Caching.Memory
@using MongoDB.Driver
@inject IJSRuntime jsRuntime
@inject IConfiguration Configuration
@inject IDbContextFactory<Models.AthleteContext> DbFactory
@inject IHttpClientFactory HttpClientFactory
@inject ILogger<ContentPlayer> Logger
@inject Utilities.StravaOAuth OAuth
@inject Utilities.BluetoothHandler BluetoothHandler
@inject BluetoothLE.Services.SufferService Suffer
@inject Utilities.IntervalsUploader Intervals
@implements IAsyncDisposable
@rendermode @(new InteractiveServerRenderMode(prerender: false))

<PageTitle>Content Player</PageTitle>

<style type="text/css">
    /* track */
    input[type=range] {
    -webkit-appearance: none; /* Hides the slider so that custom slider can be made */
    width: 100%; /* Specific width is required for Firefox. */
    background: transparent; /* Otherwise white in Chrome */
    height: 100%;
    }

    input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    }

    input[type=range]:focus {
    outline: none; /* Removes the blue border. You should probably do some kind of focus styling for accessibility reasons though. */
    }

    input[type=range]::-ms-track {
    width: 100%;
    cursor: pointer;
    /* Hides the slider so custom styles can be added */
    background: transparent;
    border-color: transparent;
    color: transparent;
    }

    /* thumb */
    input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    border: 1px solid yellow;
    height: 100px;
    width: 1px;
    cursor: pointer;
    margin-top: 0;
    }
</style>

@if (_timer is null || _timer.Period == Timeout.InfiniteTimeSpan)
{
    <button style="left: 4px; top: 4px;" onclick="@BluetoothHandler.ConnectAsync">Connect to BLE</button>

    if (IsAuthenticated)
    {
        <button id="strava-upload" onclick="@UploadAsync" style="right: 4px; left: unset; background-color: rgb(215 70 0); color: white; padding-left: 8px; padding-right: 8px; top: 4px"><i class="fa-brands fa-strava"></i></button>
    }
}

<div >

    <BlazoredVideo @ref="video" EndedEvent="PlaybackEndedAsync">
    </BlazoredVideo>

    <div id="playback-toggle" @onclick="@(async e => await TogglePlaybackAsync())"></div>

    <style type="text/css">
        .indicator {
        stroke: yellow;
        stroke-width: 1px;
        z-index: 100;
        display: none;
        stroke: red;
        }

        #playback-toggle
        {
        position: absolute;
        width: 100%;
        height: calc(100% - 100px);
        z-index: 10000;
        }
    </style>

    <article>
        @if (videoHandler is not null && videoHandler.Story(_timelineController.CurrentMilliseconds) is StorylineParameters parameters)
        {
            <StoryLine Parameters="parameters" />
        }
    </article>

    @if (whip is StorylineParameters whipObject)
    {
        <div id="whip"><div>@whipObject.Text.En</div></div>
    }

    @if (currentTargets is WorkoutParameters targets)
    {
        var currentPower = FromParameters(targets).Value;
        var currentCadence = targets.Rpm?.Value ?? 0;

        <div id="workout-display">
            <div id="heart-rate" class="target-grid">
                <div class="current-value">@FromInt(actualHeartRate)</div>
                <div class="current-icon"><i class="fa-light fa-heart icon"></i></div>
                <div class="target-value"></div>
                <div class="upcoming-value"></div>
            </div>
            <div id="power" class="target-grid">
                <div class="target-value">@currentPower</div>
                <UpcomingValue CurrentTarget="currentPower" CurrentPosition="_timelineController.CurrentMilliseconds"
                Parameters="effortChangeObject" UpcomingParameters="upcomingTargets"
                GetUpcoming="(parameters) => FromParameters(parameters).Value"></UpcomingValue>
                <div class="current-value" style="background-color: @ColorDiff(currentPower, actualPower ?? 0, 10)">@FromInt(actualPower)</div>
                <div class="current-icon"><i class="fa-light fa-bolt icon"></i></div>
            </div>
            <div id="cadence" class="target-grid">
                <div class="target-value">@currentCadence</div>
                <UpcomingValue CurrentTarget="currentCadence" CurrentPosition="_timelineController.CurrentMilliseconds"
                Parameters="effortChangeObject" UpcomingParameters="upcomingTargets"
                GetUpcoming="(parameters => parameters.Rpm?.Value ?? 0)"></UpcomingValue>
                <div class="current-value" style="background-color: @ColorDiff(currentCadence, actualCadence ?? 0, 5)">@FromInt(actualCadence)</div>
                <div class="current-icon"><i class="fa-light fa-sync icon"></i></div>
            </div>
            <div id="graph-container">
                <div id="graph" style="position:relative">
                    @if (workoutBuilder is not null)
                    {
                        <input type="range" id="seek-bar" disabled="@(PlaybackPlaying)" @bind="SeekBarPosition" @bind:after="ChangePositionAsync" min="0" max="@workoutBuilder.Width" style="width:@(workoutBuilder.Width / 4)px; position: relative; z-index: 1000"/>
                        <svg style="position: absolute; top: 0; left: 0" width="@workoutBuilder.Width" height="@workoutBuilder.Height" viewBox="0 0 @workoutBuilder.Width @workoutBuilder.Height">
                            <rect width="@workoutBuilder.Width" height="@workoutBuilder.Height" x="0" y="0" fill="none"/>
                            <g>
                                @foreach (var item in workoutBuilder.Paths())
                                {
                                    <path d="@item.Fill" fill="@item.Colour" fill-opacity="1" stroke="none" class="@item.Class"></path>
                                }
                            </g>
                        </svg>
                    }
                </div>

                <div id="hr-graph">

                    @if (heartRateBuilder is not null)
                    {
                        <svg width="@heartRateBuilder.Width" height="@heartRateBuilder.Height" viewBox="0 0 @heartRateBuilder.Width @heartRateBuilder.Height">
                            <rect width="@heartRateBuilder.Width" height="@heartRateBuilder.Height" x="0" y="0" fill="none" />
                            <g>
                                @foreach (var item in heartRateBuilder.Paths())
                                {
                                    <path d="@item.Stroke" fill="none" stroke="@item.Colour" class="@item.Class"></path>
                                }
                            </g>
                        </svg>
                    }
                </div>
                <div id="power-graph">

                    @if (powerBuilder is not null)
                    {
                        <svg width="@powerBuilder.Width" height="@powerBuilder.Height" viewBox="0 0 @powerBuilder.Width @powerBuilder.Height">
                            <rect width="@powerBuilder.Width" height="@powerBuilder.Height" x="0" y="0" fill="none" />
                            <g>
                                @foreach (var item in powerBuilder.Paths())
                                {
                                    <path d="@item.Stroke" fill="none" stroke="@item.Colour" class="@item.Class"></path>
                                }
                            </g>
                        </svg>
                    }
                </div>
                <div id="elapsed-time">@FormatTimeSpan(_timelineController.TotalTime)</div>
                <div id="track-remaining-time"><div>@FormatTimeSpan(trackRemainingTime)</div></div>
                <div id="total-remaining-time">@FormatTimeSpan(workoutRemainingTime)</div>
            </div>
        </div>
    }

</div>

<audio id="effort_increase" src="sounds/effort_increase.mp3"></audio>
<audio id="effort_decrease" src="sounds/effort_decrease.mp3"></audio>
<audio id="effort_change_coming" src="sounds/effort_change_coming.mp3"></audio>
<audio id="attack" src="sounds/attack.mp3"></audio>
<audio id="slide_in" src="sounds/slide_in.mp3"></audio>
<audio id="slide_out" src="sounds/slide_out.mp3"></audio>
<audio id="stand" src="sounds/stand.mp3"></audio>
<audio id="surge" src="sounds/surge.mp3"></audio>

<script type="text/javascript">
    console.log("setting up sound effect init function...");
    window.audioTracks = {};
    window.setupSoundEffects = () => {
    document.querySelectorAll('audio').forEach((audioElement) => {
    console.log("initializing sound effects");

    const id = audioElement.id;

    let context = new AudioContext();
    let track = context.createMediaElementSource(audioElement);

    track.connect(context.destination);

    window.audioTracks[id] = { element: audioElement, context, track };
    });

    window.playSoundEffect = (id) => window.audioTracks[id].element.play();
    }

    console.log("trying to enter fullscreen...");
    document.documentElement.requestFullscreen({ navigationUI: "hide" })
    .then(() => { console.log("entered fullscreen") })
    .catch((err) => { console.log(`failed to enter fullscreen: ${err.message}`) });
</script>

@code {
    [Parameter]
    public string Content { get; set; } = "Indoor Cycling";

    private string ColorDiff(int currentTarget, int actualValue, int safeValue)
    {
        int diff = currentTarget - actualValue;

        if (Math.Abs(diff) <= safeValue) {
            return "none";
        }

        if (diff > (safeValue * 10)) diff = safeValue * 10;
        if (diff < (safeValue * -10)) diff = safeValue * -10;

        double percentage = Math.Abs((double)diff) / (double)(safeValue * 10);

        if (diff > 0) {
            int red = (int)(255 * percentage);
            return $"rgb({red} 0 0 / 50%)";
        }
        else {
            int blue = (int)(255 * percentage);
            int green = (int)(127 * percentage);
            return $"rgb(0 {green} {blue} / 50%)";
        }
    }

    WorkoutParameters? currentTargets = null;
    WorkoutParameters? upcomingTargets = null;
    StorylineParameters? whip = null;
    Object<WorkoutParameters>? effortChangeObject = null;

    TimeSpan workoutRemainingTime = TimeSpan.Zero;
    TimeSpan trackRemainingTime = TimeSpan.Zero;

    MarkupString FromInt(int? value) => value is null ? new MarkupString("&mdash;") : new MarkupString($"{value.Value}");

    TimelineController _timelineController = new();

    Blazored.Video.BlazoredVideo video;

    private int SeekBarPosition { get; set; } = 0;

    private bool PlaybackPlaying { get; set; } = false;

    PeriodicTimer? _timer;
    Task? _timerTask;
    bool _disposed = false;

    string Story = string.Empty;

    bool initSoundEffects = false;

    record struct SoundEffect(int StartTime, int Duration, string EffectName, bool Started);
    record struct Target(int StartTime, int Duration, int Power, bool Increase);

    Queue<SoundEffect> soundEffects = [];
    Queue<Target> targetChanges = [];

    Utilities.FitFileHandler? _fitFileHandler;

    async Task ChangePositionAsync()
    {
        if (await video.GetPausedAsync() is false)
        {
            Console.WriteLine($"Skipping changing position, currently playing...");
            return;
        }

        Console.WriteLine($"New position: {SeekBarPosition}");

        // Should there be a controller class that handles all of this?
        _timelineController.Reposition(SeekBarPosition);

        await video.SetCurrentTimeAsync(SeekBarPosition);

        // Other things to do:
        // - Set record of stop time to all zero values
        // - Create lap marker
        // - Create a record of start time to all zero values?
        //   This might be better handled in the play/pause logic?
        //   Unfortunately, currently, as soon as set position, playback resumes... need to fix that

        Console.WriteLine($"Resetting timelines for sync...");

        workoutHandler?.ResetTimelines();

        // More things to consider:
        // - Updating the workout graph to cut out skipped over blocks
        // - Updating the workout graph to insert repeated blocks
        // - Updating the data graphs to the new length so it's not overwriting existing graph data

        // With the above, we can't use video position for some of the indexing...
    }

    async Task TogglePlaybackAsync()
    {
        try
        {
            if (initSoundEffects is false)
            {
                initSoundEffects = true;

                await jsRuntime.InvokeVoidAsync("setupSoundEffects");
            }

            Console.WriteLine("Toggling workout...");

            if (_timer is null)
            {
                Logger.LogError("Unable to toggle playback state, have no timer!");

                return;
            }

            if (_timerTask is null)
            {
                _timerTask = UpdateState();
            }

            if (await video.GetPausedAsync())
            {
                _timelineController.Start();

                await video.StartPlayback();

                PlaybackPlaying = true;

                _timer.Period = TimeSpan.FromMilliseconds(100);

                if (_fitFileHandler is null)
                {
                    _fitFileHandler = new(ContentName);
                }
            }
            else
            {
                _timelineController.Pause();

                await video.PausePlayback();

                PlaybackPlaying = false;

                _timer.Period = Timeout.InfiniteTimeSpan;
            }
        } catch (Exception exn)
        {
            Logger.LogError($"Unable to toggle playback: {exn.Message}");
            Logger.LogError($"Stack Trace: {exn.StackTrace}");
        }
    }

    private async Task PlaybackEndedAsync(Blazored.Video.Support.VideoState state)
    {
        Logger.LogInformation("Playback has ended, closing fit file");

        _timelineController.Stop();

        BluetoothHandler.Disconnect();

        if (_timer is not null)
        {
            _timer.Period = Timeout.InfiniteTimeSpan;
        }

        CloseFitFile();

        await InvokeAsync(StateHasChanged);
    }

    private void CloseFitFile()
    {
        if (_fitFileHandler is null)
        {
            Logger.LogInformation("Have already closed the fit file, aborting");

            return;
        }

        _timelineController.Stop();

        var lastLap = _laps.LastOrDefault();

        if (lastLap is not null)
        {
            lastLap.EndLap(_timelineController.EndedAt.Value);

            int durationMs = _lastTrack?.Size ?? 0;

            _fitFileHandler?.AddLap(lastLap, durationMs);
        }

        _memoryStream = _fitFileHandler?.Close(_timelineController.EndedAt.Value - _timelineController.ElapsedTime,
            _timelineController.EndedAt.Value,
            _timelineController.TotalTime.TotalSeconds,
            Models.Lap.TotalSummary(_laps));

        _fitFileHandler?.Dispose();
        _fitFileHandler = null;
    }

    private MemoryStream? _memoryStream;

    private IReadOnlyList<WorkoutTrigger> workoutJson = [];

    private bool IsAuthenticated { get; set; } = false;

    async Task<string> LocateVideoPath()
    {
        var contentItem = await Suffer.ContentCollection.Find(item => item.Id == Content).SingleAsync();

        string fileKey = $"[{contentItem.Id}-{contentItem.WorkoutId}-{contentItem.VideoId}]";

        return System.IO.Path.GetFileName(System.IO.Directory.EnumerateFiles(@"G:\videos", "*.mp4").SingleOrDefault(item => item.Contains(fileKey)) ?? string.Empty);
    }

    private string ContentName { get; set; } = "Indoor Cycling";

    protected override bool ShouldRender()
    {
        return videoHandler is not null && workoutHandler is not null;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
            return;

        var contentItem = await Suffer.ContentCollection.Find(item => item.Id == Content).SingleAsync();

        try
        {
            await video.SetSrcAsync($"/videos/{contentItem.VideoId}.mp4");
        } catch (Exception setSrcException)
        {
            Logger.LogError($"Unable to set source: {setSrcException.Message}");
            Logger.LogError($"@video = {video}");

            throw setSrcException;
        }
    }

    protected override async Task OnInitializedAsync()
    {
        // TODO: support multiple users, for now, just hard-coding `1`.
        try
        {
            IsAuthenticated = await OAuth.HasAccessToken(1);
        }
        catch { }

        var contentItem = await Suffer.ContentCollection.Find(item => item.Id == Content).SingleAsync();

        ContentName = contentItem.Name;

        var workoutTriggers = contentItem.Workout;

        var videoTriggers = contentItem.Storylines;

        if (videoTriggers is not null && videoTriggers.Count == 1)
        {
            videoHandler = new(videoTriggers[0]);

            _timer = new(Timeout.InfiniteTimeSpan);

            Logger.LogInformation("Started storyline");
        }
        else
        {
            throw new ArgumentOutOfRangeException("json", $"Invalid number of storylines in JSON. Found {videoTriggers?.Count ?? 0}, expected 1.");
        }

        if (workoutTriggers is not null && workoutTriggers.Count > 0)
        {
            workoutJson = workoutTriggers;

            BuildWorkoutGraph(workoutJson);

            workoutHandler = new WorkoutHandler(workoutJson);

            currentTargets = workoutHandler.Targets(0);
        }

        // Just testing this out, want to do a few other tests with BLE and various pairing states
        //await BluetoothHandler.ForgetAsync();

        BluetoothHandler.OnChange += async (Utilities.BluetoothHandler.BluetoothData data) =>
        {
            // For HR, 0 is "impossible", so set to null to indicate a problem with sensor
            if (data.HeartRate is int hr) actualHeartRate = hr == 0 ? null : (byte)hr;
            if (data.Cadence is int cadence) actualCadence = (byte)cadence;
            if (data.Power is int power) actualPower = (ushort)power;

            await InvokeAsync(StateHasChanged);
        };

        _timelineController.OnIndexChanged += (int previousIndex, int currentIndex, TimelineController.TimerState timerState) =>
        {
            Console.WriteLine($"Index changed: {previousIndex} => {currentIndex}");

            if (GetCurrentTrack(currentIndex) is (int offset, Track currentTrack) && GetCurrentTrack(previousIndex) is (int prevOffset, Track previousTrack))
            {
                if (currentTrack != previousTrack)
                {
                    if (_timelineController.LapStartedAt.HasValue)
                    {
                        var lapLength = System.DateTime.UtcNow - _timelineController.LapStartedAt.Value;

                        Console.WriteLine($"Previous track elapsed time: {lapLength}");
                        Console.WriteLine($"Previous track size: {previousTrack.Size}");
                    }

                    // Starting a new track (lap)
                    _timelineController.Mark();
                }

                if (_lastTrack is null || currentTrack != previousTrack)
                {
                    // Need to add a lap... what do we need?
                    var previousLap = _laps.LastOrDefault();

                    if (previousLap is not null)
                    {
                        previousLap.EndLap(System.DateTime.UtcNow);

                        // Yeah, see this doesn't really work...
                        int durationMs = previousTrack.Size;

                        _fitFileHandler?.AddLap(previousLap, durationMs);
                    }

                    // I don't like this... it should go into the FIT file handler...
                    _laps.Add(new Models.Lap(System.DateTime.UtcNow, currentTrack.Size / 1000));

                    _lastTrack = currentTrack;

                    _laps.Last().Add(actualHeartRate ?? 0, actualCadence ?? 0, actualPower ?? 0);
                }
            }

            if (timerState == TimelineController.TimerState.Playing)
            {
                _fitFileHandler?.AddRecord(System.DateTime.UtcNow, actualHeartRate ?? 0, actualCadence ?? 0, actualPower ?? 0);
            }
        };

        await InvokeAsync(StateHasChanged);
    }

    string FormatColour(IReadOnlyList<double> components)
    {
        int Rgb(double percentage) => (int)(255.0 * percentage);

        if (components.Count == 4)
        {
            return $"rgb({Rgb(components[0])} {Rgb(components[1])} {Rgb(components[2])} / {(int)(components[3] * 100)}%)";
        }
        else
        {
            return $"rgb({Rgb(components[0])} {Rgb(components[1])} {Rgb(components[2])})";
        }
    }

    VideoHandler? videoHandler = null;
    WorkoutHandler? workoutHandler = null;

    private System.DateTime last = System.DateTime.Now;

    private Track? _lastTrack = null;

    private (int Offset, Track Track)? GetCurrentTrack(int offset)
    {
        int currentOffset = 0;

        foreach (var root in workoutJson)
        {
            foreach (var track in root.Tracks)
            {
                if (offset >= currentOffset && offset <= currentOffset + track.Size)
                {
                    return (currentOffset, track);
                }

                currentOffset += track.Size;
            }
        }

        return null;
    }

    private int lastLength = 0;

    private List<Models.Lap> _laps = [];

    private async Task UpdateState()
    {
        try
        {
            while (await _timer!.WaitForNextTickAsync())
            {
                if (_disposed)
                    return;

                try
                {
                    double videoTime = await video.GetCurrentTimeAsync();

                    // Currently, `TimelineController` doesn't update the timer... so
                    // let's do that here from the video time (which is in seconds)
                    _timelineController.UpdateIndex(videoTime);

                    int currentPosition = _timelineController.CurrentMilliseconds;

                    SeekBarPosition = _timelineController.CurrentIndex;

                    currentTargets = workoutHandler?.Targets(currentPosition);
                    upcomingTargets = workoutHandler?.NextTargets(currentPosition);
                    effortChangeObject = workoutHandler?.EffortChangeObject(currentPosition);
                    whip = videoHandler?.Whip(currentPosition);

                    if (workoutHandler?.SoundEffect(currentPosition) is WorkoutParameters workoutSoundEffect)
                    {
                        Logger.LogInformation($"Playing sound effect: {workoutSoundEffect.Key}");

                        await jsRuntime.InvokeVoidAsync("playSoundEffect", workoutSoundEffect.Key);
                    }

                    if (videoHandler?.SoundEffect(currentPosition) is StorylineParameters videoSoundEffect)
                    {
                        await jsRuntime.InvokeVoidAsync("playSoundEffect", videoSoundEffect.Key);
                    }

                    var currentTrack = GetCurrentTrack(currentPosition);

                    try
                    {
                        if (currentTrack is not null)
                        {
                            var elapsed = currentPosition - currentTrack.Value.Offset;
                            trackRemainingTime = TimeSpan.FromMilliseconds(currentTrack.Value.Track.Size - elapsed).Add(TimeSpan.FromSeconds(1));
                        }

                        // GetDurationAsync() returns a non-integer value, throws exception
                        //workoutRemainingTime = TimeSpan.FromSeconds(await video.GetDurationAsync() - (int)videoTime);
                        int workoutTime = workoutJson.SelectMany(root => root.Tracks.Select(track => track.Size)).Sum();

                        if (workoutTime > currentPosition)
                        {
                            workoutRemainingTime = TimeSpan.FromMilliseconds(workoutTime - currentPosition);
                        }
                        else
                        {
                            workoutRemainingTime = TimeSpan.Zero;
                        }
                    } catch (Exception exn)
                    {
                        Logger.LogError($"Error trying to update timers: {exn.Message}");
                        Logger.LogError($"Stack trace: {exn.StackTrace}");
                    }

                    var currentUpdate = TimeOnly.FromDateTime(System.DateTime.UtcNow);

                    int index = (int)Math.Floor(videoTime);

                    // use a loop for when rendering is lagging, ensure the graph always has values...
                    if (heartRateBuilder is not null)
                    {
                        for (int ix = lastLength + 1; ix <= index; ++ix)
                            heartRateBuilder.Data[ix] = actualHeartRate ?? 0;
                        heartRateBuilder.Length = index + 1;
                    }

                    if (powerBuilder is not null)
                    {
                        for (int ix = lastLength + 1; ix <= index; ++ix)
                            powerBuilder.Data[ix] = actualPower ?? 0;
                        powerBuilder.Length = index + 1;
                    }

                    if (cadenceBuilder is not null)
                    {
                        for (int ix = lastLength + 1; ix <= index; ++ix)
                            cadenceBuilder.Data[ix] = actualCadence ?? 0;
                        cadenceBuilder.Length = index + 1;
                    }

                    if (index > lastLength)
                    {
                        lastLength = index;
                    }

                    await InvokeAsync(StateHasChanged);
                } catch (Exception innerExn)
                {
                    Logger.LogError($"Derp: {innerExn.Message}");
                }
            }
        }
        catch (OperationCanceledException exn)
        {
            // can we dispose of the timer here?
            Console.WriteLine($"update state has failed: {exn.Message}");
        }
    }

    string FormatTimeSpan(TimeSpan timeSpan)
    {
        if (timeSpan.Hours > 0)
        {
            return timeSpan.ToString(@"h':'mm':'ss");
        }
        else
        {
            return timeSpan.ToString(@"m':'ss");
        }
    }

    private Models.Stats? AthleteStats { get; set; }

    private WorkoutItem FromParameters(WorkoutParameters parameters)
    {
        if (AthleteStats is null)
        {
            using var context = DbFactory.CreateDbContext();

            try
            {
                AthleteStats = context.Stats.Where(item => item.Id == 1).SingleOrDefault();
            }
            catch (Exception exn)
            {
                Logger.LogError($"Unable to load athlete stats: {exn.Message}");

                return new(BluetoothLE.Target.FTP, 0);
            }
        }

        if (AthleteStats is null || parameters is null)
            return new(BluetoothLE.Target.FTP, 0);

        if (parameters.Nm is TypedValue<double> nm)
        {
            return new(BluetoothLE.Target.NM, (ushort)(AthleteStats.Nm * nm.Value));
        }
        else if (parameters.Ac is TypedValue<double> ac)
        {
            return new(BluetoothLE.Target.AC, (ushort)(AthleteStats.Ac * ac.Value));
        }
        else if (parameters.Map is TypedValue<double> map)
        {
            return new(BluetoothLE.Target.MAP, (ushort)(AthleteStats.Map * map.Value));
        }
        else if (parameters.Ftp is TypedValue<double> ftp)
        {
            return new(BluetoothLE.Target.FTP, (ushort)(AthleteStats.Ftp * ftp.Value));
        }
        else throw new ArgumentException("Don't have a power target to show");
    }

    private void BuildWorkoutGraph(IReadOnlyList<WorkoutTrigger> workout)
    {
        List<WorkoutItem> workoutValues = [];

        int trackOffset = 0;

        foreach (var section in workout)
        {
            //Console.WriteLine($"Processing section {section.Name}");

            foreach (var track in section.Tracks)
            {
                //Console.WriteLine($"  Processing track of type {track.Type}");

                int size = track.Size;

                if (track.SizeType != "time")
                {
                    //Console.WriteLine($"    Track doesn't have a duration; size type is {track.SizeType}");

                    continue;
                }

                for (int ix = 0; ix < track.Objects.Count; ++ix)
                {
                    var obj = track.Objects[ix];

                    if (obj.Type == StringKeys.Targets)
                    {
                        for (int iy = 0; iy < (obj.Size / 1000); ++iy)
                        {
                            workoutValues.Add(FromParameters(obj.Parameters));
                        }
                    }
                }

                trackOffset += track.Size;
            }
        }

        var maxPower = (int)Math.Ceiling((double)workoutValues.MaxBy(value => value.Value).Value / 10) * 10 + 50;

        //Console.WriteLine($"Max Power Value: {maxPower}W");

        // The new graph handling
        workoutBuilder = new GraphBuilder<WorkoutItem>(new WorkoutItemTransformer(), workoutValues.Count, 100, maxPower)
            {
                CreateStroke = false,
                JoinBlocks = false,
                Length = workoutValues.Count
            };
        heartRateBuilder = new GraphBuilder<int>(new ValueTransformer("rgb(255 0 0)"), workoutValues.Count, 100, 200)
            {
                CreateFill = false,
                JoinBlocks = false
            };
        cadenceBuilder = new GraphBuilder<int>(new ValueTransformer("rgb(0 0 255)"), workoutValues.Count, 100, 200)
            {
                CreateFill = false,
                JoinBlocks = false
            };
        powerBuilder = new GraphBuilder<int>(new ValueTransformer("rgb(255 255 255)"), workoutValues.Count, 100, maxPower)
            {
                CreateFill = false,
                JoinBlocks = false
            };

        workoutBuilder.Data = workoutValues.ToArray();
    }

    public async ValueTask DisposeAsync()
    {
        if (_disposed)
            return;

        _disposed = true;

        CloseFitFile();

        await BluetoothHandler.ForgetAsync();

        if (_timerTask is not null)
        {
            await _timerTask;
            _timerTask = null;
        }

        _timer?.Dispose();
        _timer = null;
    }

    public async Task UploadAsync()
    {
        CloseFitFile();

        if (_memoryStream is null)
        {
            Logger.LogError($"Nothing to upload, _memoryStream is null!");

            return;
        }

        string externalId = Convert.ToBase64String(System.Security.Cryptography.RandomNumberGenerator.GetBytes(8));

        await Intervals.UploadAsync(1, $"The Sufferfest: {ContentName}", _memoryStream, externalId);
        await OAuth.UploadAsync(1, $"The Sufferfest: {ContentName}", _memoryStream, externalId, "Ride");
    }

    private GraphBuilder<WorkoutItem>? workoutBuilder = null;
    private GraphBuilder<int>? heartRateBuilder = null;
    private GraphBuilder<int>? powerBuilder = null;
    private GraphBuilder<int>? cadenceBuilder = null;

    int? actualHeartRate = null;
    int? actualCadence = null;
    int? actualPower = null;
}
